import { PublicClientApplication } from "@azure/msal-node";
import keytar from "keytar";
import logger from "./logger.js";
import fs, { existsSync, readFileSync } from "fs";
import { fileURLToPath } from "url";
import path from "path";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const endpointsData = JSON.parse(
  readFileSync(path.join(__dirname, "endpoints.json"), "utf8")
);
const endpoints = {
  default: endpointsData
};
const SERVICE_NAME = "ms-365-mcp-server";
const TOKEN_CACHE_ACCOUNT = "msal-token-cache";
const SELECTED_ACCOUNT_KEY = "selected-account";
const FALLBACK_DIR = path.dirname(fileURLToPath(import.meta.url));
const FALLBACK_PATH = path.join(FALLBACK_DIR, "..", ".token-cache.json");
const SELECTED_ACCOUNT_PATH = path.join(FALLBACK_DIR, "..", ".selected-account.json");
const DEFAULT_CONFIG = {
  auth: {
    clientId: process.env.MS365_MCP_CLIENT_ID || "084a3e9f-a9f4-43f7-89f9-d229cf97853e",
    authority: `https://login.microsoftonline.com/${process.env.MS365_MCP_TENANT_ID || "common"}`
  }
};
const SCOPE_HIERARCHY = {
  "Mail.ReadWrite": ["Mail.Read"],
  "Calendars.ReadWrite": ["Calendars.Read"],
  "Files.ReadWrite": ["Files.Read"],
  "Tasks.ReadWrite": ["Tasks.Read"],
  "Contacts.ReadWrite": ["Contacts.Read"]
};
function buildScopesFromEndpoints(includeWorkAccountScopes = false) {
  const scopesSet = /* @__PURE__ */ new Set();
  endpoints.default.forEach((endpoint) => {
    if (!includeWorkAccountScopes && !endpoint.scopes && endpoint.workScopes) {
      return;
    }
    if (endpoint.scopes && Array.isArray(endpoint.scopes)) {
      endpoint.scopes.forEach((scope) => scopesSet.add(scope));
    }
    if (includeWorkAccountScopes && endpoint.workScopes && Array.isArray(endpoint.workScopes)) {
      endpoint.workScopes.forEach((scope) => scopesSet.add(scope));
    }
  });
  Object.entries(SCOPE_HIERARCHY).forEach(([higherScope, lowerScopes]) => {
    if (lowerScopes.every((scope) => scopesSet.has(scope))) {
      lowerScopes.forEach((scope) => scopesSet.delete(scope));
      scopesSet.add(higherScope);
    }
  });
  return Array.from(scopesSet);
}
class AuthManager {
  constructor(config = DEFAULT_CONFIG, scopes = buildScopesFromEndpoints()) {
    logger.info(`And scopes are ${scopes.join(", ")}`, scopes);
    this.config = config;
    this.scopes = scopes;
    this.msalApp = new PublicClientApplication(this.config);
    this.accessToken = null;
    this.tokenExpiry = null;
    this.selectedAccountId = null;
    const oauthTokenFromEnv = process.env.MS365_MCP_OAUTH_TOKEN;
    this.oauthToken = oauthTokenFromEnv ?? null;
    this.isOAuthMode = oauthTokenFromEnv != null;
  }
  async loadTokenCache() {
    try {
      let cacheData;
      try {
        const cachedData = await keytar.getPassword(SERVICE_NAME, TOKEN_CACHE_ACCOUNT);
        if (cachedData) {
          cacheData = cachedData;
        }
      } catch (keytarError) {
        logger.warn(
          `Keychain access failed, falling back to file storage: ${keytarError.message}`
        );
      }
      if (!cacheData && existsSync(FALLBACK_PATH)) {
        cacheData = readFileSync(FALLBACK_PATH, "utf8");
      }
      if (cacheData) {
        this.msalApp.getTokenCache().deserialize(cacheData);
      }
      await this.loadSelectedAccount();
    } catch (error) {
      logger.error(`Error loading token cache: ${error.message}`);
    }
  }
  async loadSelectedAccount() {
    try {
      let selectedAccountData;
      try {
        const cachedData = await keytar.getPassword(SERVICE_NAME, SELECTED_ACCOUNT_KEY);
        if (cachedData) {
          selectedAccountData = cachedData;
        }
      } catch (keytarError) {
        logger.warn(
          `Keychain access failed for selected account, falling back to file storage: ${keytarError.message}`
        );
      }
      if (!selectedAccountData && existsSync(SELECTED_ACCOUNT_PATH)) {
        selectedAccountData = readFileSync(SELECTED_ACCOUNT_PATH, "utf8");
      }
      if (selectedAccountData) {
        const parsed = JSON.parse(selectedAccountData);
        this.selectedAccountId = parsed.accountId;
        logger.info(`Loaded selected account: ${this.selectedAccountId}`);
      }
    } catch (error) {
      logger.error(`Error loading selected account: ${error.message}`);
    }
  }
  async saveTokenCache() {
    try {
      const cacheData = this.msalApp.getTokenCache().serialize();
      try {
        await keytar.setPassword(SERVICE_NAME, TOKEN_CACHE_ACCOUNT, cacheData);
      } catch (keytarError) {
        logger.warn(
          `Keychain save failed, falling back to file storage: ${keytarError.message}`
        );
        fs.writeFileSync(FALLBACK_PATH, cacheData);
      }
    } catch (error) {
      logger.error(`Error saving token cache: ${error.message}`);
    }
  }
  async saveSelectedAccount() {
    try {
      const selectedAccountData = JSON.stringify({ accountId: this.selectedAccountId });
      try {
        await keytar.setPassword(SERVICE_NAME, SELECTED_ACCOUNT_KEY, selectedAccountData);
      } catch (keytarError) {
        logger.warn(
          `Keychain save failed for selected account, falling back to file storage: ${keytarError.message}`
        );
        fs.writeFileSync(SELECTED_ACCOUNT_PATH, selectedAccountData);
      }
    } catch (error) {
      logger.error(`Error saving selected account: ${error.message}`);
    }
  }
  async setOAuthToken(token) {
    this.oauthToken = token;
    this.isOAuthMode = true;
  }
  async getToken(forceRefresh = false) {
    if (this.isOAuthMode && this.oauthToken) {
      return this.oauthToken;
    }
    if (this.accessToken && this.tokenExpiry && this.tokenExpiry > Date.now() && !forceRefresh) {
      return this.accessToken;
    }
    const currentAccount = await this.getCurrentAccount();
    if (currentAccount) {
      const silentRequest = {
        account: currentAccount,
        scopes: this.scopes
      };
      try {
        const response = await this.msalApp.acquireTokenSilent(silentRequest);
        this.accessToken = response.accessToken;
        this.tokenExpiry = response.expiresOn ? new Date(response.expiresOn).getTime() : null;
        return this.accessToken;
      } catch {
        logger.error("Silent token acquisition failed");
        throw new Error("Silent token acquisition failed");
      }
    }
    throw new Error("No valid token found");
  }
  async getCurrentAccount() {
    const accounts = await this.msalApp.getTokenCache().getAllAccounts();
    if (accounts.length === 0) {
      return null;
    }
    if (this.selectedAccountId) {
      const selectedAccount = accounts.find(
        (account) => account.homeAccountId === this.selectedAccountId
      );
      if (selectedAccount) {
        return selectedAccount;
      }
      logger.warn(
        `Selected account ${this.selectedAccountId} not found, falling back to first account`
      );
    }
    return accounts[0];
  }
  async acquireTokenByDeviceCode(hack) {
    const deviceCodeRequest = {
      scopes: this.scopes,
      deviceCodeCallback: (response) => {
        const text = ["\n", response.message, "\n"].join("");
        if (hack) {
          hack(text + 'After login run the "verify login" command');
        } else {
          console.log(text);
        }
        logger.info("Device code login initiated");
      }
    };
    try {
      logger.info("Requesting device code...");
      logger.info(`Requesting scopes: ${this.scopes.join(", ")}`);
      const response = await this.msalApp.acquireTokenByDeviceCode(deviceCodeRequest);
      logger.info(`Granted scopes: ${response?.scopes?.join(", ") || "none"}`);
      logger.info("Device code login successful");
      this.accessToken = response?.accessToken || null;
      this.tokenExpiry = response?.expiresOn ? new Date(response.expiresOn).getTime() : null;
      if (!this.selectedAccountId && response?.account) {
        this.selectedAccountId = response.account.homeAccountId;
        await this.saveSelectedAccount();
        logger.info(`Auto-selected new account: ${response.account.username}`);
      }
      await this.saveTokenCache();
      return this.accessToken;
    } catch (error) {
      logger.error(`Error in device code flow: ${error.message}`);
      throw error;
    }
  }
  async testLogin() {
    try {
      logger.info("Testing login...");
      const token = await this.getToken();
      if (!token) {
        logger.error("Login test failed - no token received");
        return {
          success: false,
          message: "Login failed - no token received"
        };
      }
      logger.info("Token retrieved successfully, testing Graph API access...");
      try {
        const response = await fetch("https://graph.microsoft.com/v1.0/me", {
          headers: {
            Authorization: `Bearer ${token}`
          }
        });
        if (response.ok) {
          const userData = await response.json();
          logger.info("Graph API user data fetch successful");
          return {
            success: true,
            message: "Login successful",
            userData: {
              displayName: userData.displayName,
              userPrincipalName: userData.userPrincipalName
            }
          };
        } else {
          const errorText = await response.text();
          logger.error(`Graph API user data fetch failed: ${response.status} - ${errorText}`);
          return {
            success: false,
            message: `Login successful but Graph API access failed: ${response.status}`
          };
        }
      } catch (graphError) {
        logger.error(`Error fetching user data: ${graphError.message}`);
        return {
          success: false,
          message: `Login successful but Graph API access failed: ${graphError.message}`
        };
      }
    } catch (error) {
      logger.error(`Login test failed: ${error.message}`);
      return {
        success: false,
        message: `Login failed: ${error.message}`
      };
    }
  }
  async logout() {
    try {
      const accounts = await this.msalApp.getTokenCache().getAllAccounts();
      for (const account of accounts) {
        await this.msalApp.getTokenCache().removeAccount(account);
      }
      this.accessToken = null;
      this.tokenExpiry = null;
      this.selectedAccountId = null;
      try {
        await keytar.deletePassword(SERVICE_NAME, TOKEN_CACHE_ACCOUNT);
        await keytar.deletePassword(SERVICE_NAME, SELECTED_ACCOUNT_KEY);
      } catch (keytarError) {
        logger.warn(`Keychain deletion failed: ${keytarError.message}`);
      }
      if (fs.existsSync(FALLBACK_PATH)) {
        fs.unlinkSync(FALLBACK_PATH);
      }
      if (fs.existsSync(SELECTED_ACCOUNT_PATH)) {
        fs.unlinkSync(SELECTED_ACCOUNT_PATH);
      }
      return true;
    } catch (error) {
      logger.error(`Error during logout: ${error.message}`);
      throw error;
    }
  }
  // Multi-account support methods
  async listAccounts() {
    return await this.msalApp.getTokenCache().getAllAccounts();
  }
  async selectAccount(accountId) {
    const accounts = await this.listAccounts();
    const account = accounts.find((acc) => acc.homeAccountId === accountId);
    if (!account) {
      logger.error(`Account with ID ${accountId} not found`);
      return false;
    }
    this.selectedAccountId = accountId;
    await this.saveSelectedAccount();
    this.accessToken = null;
    this.tokenExpiry = null;
    logger.info(`Selected account: ${account.username} (${accountId})`);
    return true;
  }
  async removeAccount(accountId) {
    const accounts = await this.listAccounts();
    const account = accounts.find((acc) => acc.homeAccountId === accountId);
    if (!account) {
      logger.error(`Account with ID ${accountId} not found`);
      return false;
    }
    try {
      await this.msalApp.getTokenCache().removeAccount(account);
      if (this.selectedAccountId === accountId) {
        this.selectedAccountId = null;
        await this.saveSelectedAccount();
        this.accessToken = null;
        this.tokenExpiry = null;
      }
      logger.info(`Removed account: ${account.username} (${accountId})`);
      return true;
    } catch (error) {
      logger.error(`Failed to remove account ${accountId}: ${error.message}`);
      return false;
    }
  }
  getSelectedAccountId() {
    return this.selectedAccountId;
  }
}
var auth_default = AuthManager;
export {
  buildScopesFromEndpoints,
  auth_default as default
};
